
操作系统需要满足以下三个要求：

1. 多路复用（满足多个进程使用同一硬件的需求）
2. 隔离（不同进程之间不相互影响）
3. 交互（不同进程之间可以发生通信）

#### 2-1 抽象物理资源
操作系统把硬件资源抽象成系统调用，提供接口方便进程使用。这样实现了强隔离->禁止应用程序直接访问硬件资源，同时方便了程序的编写。

同时，操作系统在进程之间透明地切换硬件CPU，在必要时保存和恢复寄存器状态，保证对于每一个应用程序其执行过程（对它自己来说）都是不中断的（分时）。

`exec` 系统调用把内核调用其他系统调用这一过程也包装成了抽象接口，从而避免了进程对物理内存的直接操作。

#### 2-2 CPU的用户模式、监督者模式与系统调用
实现强隔离需要保证应用程序不能修改操作系统内容（=不能改变操作系统是如何执行其他进程的=不干扰其他进程），不能访问其他进程的内存。

CPU提供实现强隔离的硬件支持。在RISCV中，CPU有三种执行指令的模式：**机器模式**、**监督者（supervisor）模式**和**用户模式**。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。

监督者模式可以执行特权指令。只能执行用户模式的指令的应用程序运行在用户空间（用户态），运行在监督者模式下的软件为内核（内核态）。也就是用户态到内核态的转换本质是调用了特权指令->调用内核函数时，CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式。

#### 2-3 如何组织内核
宏内核：整个操作系统被打包放入内核，所有系统调用都在内核态下运行。xv6即使用宏内核组织。

宏内核的优缺点：

- 优点：操作系统内的所有系统调用都能使用全部的硬件，不需要针对单独的系统调用分辨硬件权限。
- 缺点：操作系统中不同部分的接口实现复杂，更容易导致内核崩溃。

微内核：在用户模式下执行操作系统的大部分指令，只有必须调用特权指令的代码（如在进程间通信）放入内核执行。

#### 2-4 xv6内核的组织方式
见原书fig2.2

#### 2-5 进程概述
进程不能破坏或监视其他进程的内存、CPU等，同时不能破坏内核，以防止隔离机制被破坏。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间片轮转。

对于程序，执行过程中进程会为其抽象出一个虚拟的私有机器，地址空间与CPU均是“私有”的，不能被其他进程读写。Xv6为每个进程维护一个单独的页表，定义该进程的地址空间，通过页表可以将虚拟地址映射成物理地址用于访存。在地址空间的顶端（地址最大的部分），xv6保留了一页，用于**trampoline**和映射进程**trapframe**的页，以便切换到内核。

进程的状态被维护在结构体 `proc` 中。每个进程都有一个执行线程（简称线程），线程执行进程的指令，可以被暂停或恢复（为CPU在进程间透明切换提供了可能）。

线程（要用到）的大部分状态（局部变量、函数调用返回地址）储存在线程的栈中：每个进程有一个用户栈和一个内核栈。在进程执行用户指令时状态储存在用户栈，而内存栈为空。在进程进入内核时，内核代码在内核栈上执行。

进程的线程在两个栈上交替执行指令：当进程执行RISC-V的 `ecall` 指令进行系统调用时，提高硬件的权限级别，PC变为内核定义的入口点，线程通过该入口点切换到内核栈，并执行系统调用的内核指令。

#### 2-6 xv6的第一个进程
这章直接看书，主要是举例子。

#### 思考部分
有的系统调用在执行完毕后直接退出，有的系统调用还会返回用户程序一些参数。