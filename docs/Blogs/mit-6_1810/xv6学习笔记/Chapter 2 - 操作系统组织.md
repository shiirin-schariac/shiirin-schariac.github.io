
操作系统需要满足以下三个要求：

1. 多路复用（满足多个进程使用同一硬件的需求）
2. 隔离（不同进程之间不相互影响）
3. 交互（不同进程之间可以发生通信）

### 2-1 抽象物理资源
操作系统把硬件资源抽象成系统调用，提供接口方便进程使用。这样实现了强隔离->禁止应用程序直接访问硬件资源，同时方便了程序的编写。

同时，操作系统在进程之间透明地切换硬件CPU，在必要时保存和恢复寄存器状态，保证对于每一个应用程序其执行过程（对它自己来说）都是不中断的（分时）。

`exec` 系统调用把内核调用其他系统调用这一过程也包装成了抽象接口，从而避免了进程对物理内存的直接操作。

### 2-2 CPU的用户模式、监督者模式与系统调用
实现强隔离需要保证应用程序不能修改操作系统内容（=不能改变操作系统是如何执行其他进程的=不干扰其他进程），不能访问其他进程的内存。

CPU提供实现强隔离的硬件支持。在RISCV中，CPU有三种执行指令的模式：**机器模式**、**监督者（supervisor）模式**和**用户模式**。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。

监督者模式可以执行特权指令。只能执行用户模式的指令的应用程序运行在用户空间（用户态），运行在监督者模式下的软件为内核（内核态）。也就是用户态到内核态的转换本质是调用了特权指令->调用内核函数时，CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式。

### 2-3 如何组织内核
宏内核：整个操作系统被打包放入内核，所有系统调用都在内核态下运行。xv6即使用宏内核组织。

宏内核的优缺点：

- 优点：操作系统内的所有系统调用都能使用全部的硬件，不需要针对单独的系统调用分辨硬件权限。
- 缺点：操作系统中不同部分的接口实现复杂，更容易导致内核崩溃。

微内核：在用户模式下执行操作系统的大部分指令，只有必须调用特权指令的代码（如在进程间通信）放入内核执行。

### 2-4 xv6内核的组织方式
| 文件        | 描述                           | 文件          | 描述                     |
| ----------- | ------------------------------ | ------------- | ------------------------ |
| bio.c       | 文件系统的磁盘块缓冲           | proc.c        | 进程和调度               |
| console.c   | 连接到用户键盘和屏幕           | sleeplock.c   | 放弃 CPU 的锁            |
| entry.S     | 第一次启动的指令               | spinlock.c    | 不放弃 CPU 的锁          |
| exec.c      | `exec()` 系统调用              | start.c       | 机器模式早期启动代码     |
| file.c      | 文件描述符                     | string.c      | C 字符串和字节数组代码库 |
| fs.c        | 文件系统                       | swtch.S       | 线程切换                 |
| kalloc.c    | 物理页分配器                   | syscall.c     | 系统调用的调度           |
| kernelvec.S | 处理来自内核的陷阱，定时器中断 | sysfile.c     | 文件相关的系统调用       |
| log.c       | 文件系统日志记录和崩溃恢复     | sysproc.c     | 进程相关的系统调用       |
| main.c      | 启动阶段控制其他模块的初始化   | trampoline.S  | 切换用户/内核模式的汇编  |
| pipe.c      | 管道                           | trap.c        | 处理陷阱和中断并从中返回 |
| plic.c      | RISC-V 中断控制器              | uart.c        | 串口控制台设备驱动       |
| printf.c    | 格式化输出到控制台             | virtio_disk.c | 磁盘设备驱动             |
| vm.c        | 管理页表和地址空间             | defs.h        | 模块间接口的定义         |

### 2-5 进程概述
进程是操作系统中最基本的隔离单位，是用户与内核交互的第一层抽象。（其后的抽象为：系统调用）

进程不能破坏或监视其他进程的内存、CPU等，同时不能破坏内核，以防止隔离机制被破坏。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间片轮转。

对于程序，执行过程中进程会为其抽象出一个虚拟的私有机器，地址空间与CPU均是“私有”的，不能被其他进程读写。

Xv6为每个进程维护一个单独的页表，定义该进程的地址空间，通过页表可以将虚拟地址映射成物理地址用于访存。

从页表的底端开始，存放的分别是：用户数据、用户栈、推数据。在地址空间的顶端（地址最大的部分），xv6保留了一页，用于**trampoline**和映射进程**trapframe**的页，以便切换到内核。

进程的状态被维护在结构体 `proc` 中。每个进程都有一个或多个执行线程（简称线程），线程执行进程的指令，可以被暂停或恢复（为CPU在进程间透明切换提供了可能）。

-> 进程是程序的运行方式，线程是进程的执行单位。

线程（要用到）的大部分状态（局部变量、函数调用返回地址）储存在线程的栈中：每个进程有一个用户栈和一个内核栈（ `p->kstack` ）。在进程执行用户指令时状态储存在用户栈，而内存栈为空。在进程进入内核时，内核代码在内核栈上执行。

进程的线程在两个栈上交替执行指令：当进程执行RISC-V的 `ecall` 指令进行系统调用时，提高硬件的权限级别，PC变为内核定义的入口点，线程通过该入口点切换到内核栈，并执行系统调用的内核指令。

-  `p->state` 表示进程是创建、就绪、运行、等待I/O，还是退出。
-  `p->pagetable` 以RISC-V硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6使分页硬件使用进程的 `p->pagetable` 。进程的页表也会记录分配给该进程内存的物理页地址。

### 2-6 xv6的第一个进程
这章直接看书，主要是举例子。

将xv6加载到 `0x80000000` 开始的内存中

-> 机器模式下CPU开始运行

-> 设置一个栈并声明其空间，执行c代码，进行初始化

-> 在函数 `start` 中调用 `mret` 指令从机器模式转换为监督者模式，程序计数器的地址变为 `main`

-> 在 `main` 中调用 `userinit` 创建第一个进程（进入用户空间）

-> 调用 `exec` 重新进入内核，执行 `/init` 程序，并在 `/init` 中返回用户空间，启动shell。

### 思考部分
有的系统调用在执行完毕后直接退出，有的系统调用还会返回用户程序一些参数。如何返回参数就是难点之一，一般创造一个指向用户的指针然后通过这个指针返回参数给用户。

关于 `mret` 指令，其实本质是让CPU返回上一个调用的模式，在 `start` 函数中，即使对于这个启动函数并不存在上一个调用，我们刻意地将上一次调用的模式设为特权者模式，以保证在函数 `start` 中可以从机器模式顺利切换到监督者模式。