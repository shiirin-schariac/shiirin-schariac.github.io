
操作系统需要满足以下三个要求：

1. 多路复用（满足多个进程使用同一硬件的需求）
2. 隔离（不同进程之间不相互影响）
3. 交互（不同进程之间可以发生通信）

为了满足这三点，操作系统按如下讲述的方式组织。

### 2-1 抽象物理资源
操作系统把硬件资源抽象成系统调用，提供接口方便进程使用。这样实现了强隔离->禁止应用程序直接访问硬件资源，同时方便了程序的编写。

同时，操作系统在进程之间透明地切换硬件CPU，在必要时保存和恢复寄存器状态，保证对于每一个应用程序其执行过程（对它自己来说）都是不中断的（分时）。

`exec` 系统调用把内核调用其他系统调用这一过程也包装成了抽象接口，从而避免了进程对物理内存的直接操作。

> 强隔离、多路复用

### 2-2 CPU的用户模式、监督者模式与系统调用
实现强隔离需要保证应用程序不能修改操作系统内容（=不能改变操作系统是如何执行其他进程的=不干扰其他进程），不能访问其他进程的内存。

CPU提供实现强隔离的硬件支持。在RISCV中，CPU有三种执行指令的模式：**机器模式**、**监督者（supervisor）模式**和**用户模式**。在机器模式下执行的指令具有完全的权限，一个CPU在机器模式下启动。机器模式主要用于配置计算机。Xv6会在机器模式下执行几条指令，然后转为监督者模式。

监督者模式可以执行特权指令。只能执行用户模式的指令的应用程序运行在用户空间（用户态），运行在监督者模式下的软件为内核（内核态）。也就是用户态到内核态的转换本质是调用了特权指令->调用内核函数时，CPU提供了一个特殊的指令，可以将CPU从用户模式切换到监督者模式。

> 强隔离

### 2-3 如何组织内核
宏内核：整个操作系统被打包放入内核，所有系统调用都在内核态下运行。xv6即使用宏内核组织。

宏内核的优缺点：

- 优点：操作系统内的所有系统调用都能使用全部的硬件，不需要针对单独的系统调用分辨硬件权限。
- 缺点：操作系统中不同部分的接口实现复杂，更容易导致内核崩溃。

微内核：在用户模式下执行操作系统的大部分指令，只有必须调用特权指令的代码（如在进程间通信）放入内核执行。

### 2-4 xv6内核的组织方式
| 文件        | 描述                           | 文件          | 描述                     |
| ----------- | ------------------------------ | ------------- | ------------------------ |
| bio.c       | 文件系统的磁盘块缓冲           | proc.c        | 进程和调度               |
| console.c   | 连接到用户键盘和屏幕           | sleeplock.c   | 放弃 CPU 的锁            |
| entry.S     | 第一次启动的指令               | spinlock.c    | 不放弃 CPU 的锁          |
| exec.c      | `exec()` 系统调用              | start.c       | 机器模式早期启动代码     |
| file.c      | 文件描述符                     | string.c      | C 字符串和字节数组代码库 |
| fs.c        | 文件系统                       | swtch.S       | 线程切换                 |
| kalloc.c    | 物理页分配器                   | syscall.c     | 系统调用的调度           |
| kernelvec.S | 处理来自内核的陷阱，定时器中断 | sysfile.c     | 文件相关的系统调用       |
| log.c       | 文件系统日志记录和崩溃恢复     | sysproc.c     | 进程相关的系统调用       |
| main.c      | 启动阶段控制其他模块的初始化   | trampoline.S  | 切换用户/内核模式的汇编  |
| pipe.c      | 管道                           | trap.c        | 处理陷阱和中断并从中返回 |
| plic.c      | RISC-V 中断控制器              | uart.c        | 串口控制台设备驱动       |
| printf.c    | 格式化输出到控制台             | virtio_disk.c | 磁盘设备驱动             |
| vm.c        | 管理页表和地址空间             | defs.h        | 模块间接口的定义         |

### 2-5 进程概述
进程是操作系统中最基本的隔离单位，是用户与内核交互的第一层抽象。（其后的抽象为：系统调用）

> 上面这段我自己当时到底是怎么想的我真的没看懂。。

进程不能破坏或监视其他进程的内存、CPU等，同时不能破坏内核，以防止隔离机制被破坏。内核用来实现进程的机制包括：用户/监督模式标志、地址空间和线程的时间片轮转。

对于程序，执行过程中进程会为其抽象出一个虚拟的私有机器，地址空间与CPU均是“私有”的，不能被其他进程读写。

Xv6为每个进程维护一个单独的页表，定义该进程的地址空间，通过页表可以将虚拟地址映射成物理地址用于访存。

从页表的底端开始，存放的分别是：用户数据、用户栈、推数据。在地址空间的顶端（地址最大的部分），xv6保留了一页，用于**trampoline**和映射进程**trapframe**的页，以便切换到内核。

进程的状态被维护在结构体 `proc` 中。每个进程都有一个或多个执行线程（简称线程），线程执行进程的指令，可以被暂停或恢复（为CPU在进程间透明切换提供了可能）。

-> 进程是程序的运行方式，线程是进程的执行单位。

> 关于多进程与多线程：
> **多进程**：使一个CPU上能够运行多个程序、有自己独立的地址空间 -> 本质为提供了多个不同的指令集（程序），让CPU可以在不同指令集间自由切换
> **多线程**：针对某一个程序使用并行思路优化其执行、多个线程使用同一个进程的地址空间（但每个线程仍然有自己独立的状态空间） -> 本质为分别执行某一个指令集中的不同指令以提高执行效率

线程（要用到）的大部分状态（局部变量、函数调用返回地址）储存在线程的栈中：每个线程有一个用户栈和一个内核栈（ `p->kstack` ）。在进程执行用户指令时状态储存在用户栈，而内存栈为空。在进程进入内核时，内核代码在内核栈上执行。

进程的线程在两个栈上交替执行指令：当进程执行RISC-V的 `ecall` 指令进行系统调用时，提高硬件的权限级别，PC变为内核定义的入口点，线程通过该入口点切换到内核栈，并执行系统调用的内核指令。

-  `p->state` 表示进程是创建、就绪、运行、等待I/O，还是退出。
-  `p->pagetable` 以RISC-V硬件需要的格式保存进程的页表，当进程在用户空间执行时，xv6使分页硬件使用进程的 `p->pagetable` 。进程的页表也会记录分配给该进程内存的物理页地址。

### 2-6 xv6的第一个进程
这章直接看书，主要是举例子。

将xv6加载到 `0x80000000` 开始的内存中

-> 机器模式下CPU开始运行

-> 设置一个栈并声明其空间，执行c代码，进行初始化

-> 在函数 `start` 中调用 `mret` 指令从机器模式转换为监督者模式，程序计数器的地址变为 `main`

-> 在 `main` 中调用 `userinit` 创建第一个进程（进入用户空间）

-> 调用 `exec` 重新进入内核，执行 `/init` 程序，并在 `/init` 中返回用户空间，启动shell。

### 思考部分
有的系统调用在执行完毕后直接退出，有的系统调用还会返回用户程序一些参数。如何返回参数就是难点之一，一般创造一个指向用户的指针然后通过这个指针返回参数给用户。

关于 `mret` 指令，其实本质是让CPU返回上一个调用的模式，在 `start` 函数中，即使对于这个启动函数并不存在上一个调用，我们刻意地将上一次调用的模式设为特权者模式，以保证在函数 `start` 中可以从机器模式顺利切换到监督者模式。

关于xv6中没有涉及的多线程编程：

为了实现并发处理问题，提出**信号量**的概念：

（在这里我们只讨论信号量用于实现多线程同步的情况，关于多进程的同步，请见第六章锁）信号量是一个多线程**共享**的变量，其中的值储存了某种资源的空余数量。

想象一个诊疗间，每次只允许三个病人进入，其余病人必须在确认门上悬挂的电子屏中显示的“剩余可进入人数”来确认自己能否进入。如果“剩余可进入人数”不为0，则一个病人进入且触摸屏上的按钮使“剩余可进入人数”减一；如果“剩余可进入人数”为0，则所有病人必须在外排队，直到诊疗间中有病人出来并触摸屏上的按钮，使“剩余可进入人数”加一。

信号量保证了诊疗间同一时间内只有有限个病人能够使用。

简化后的信号量：互斥量（类似于锁）

将以上的诊疗间模型中的“剩余可进入人数”改为诊疗间门锁，只有上锁与不上锁两种状态：进入诊疗间时必须上锁，在离开诊疗间时解锁。每个病人来到诊疗间前直接尝试拧锁，如果锁为上锁状态则排队，直到锁被出来的病人打开。

互斥量保证了诊疗间同一时间内只有一个病人能够使用。

同时，由于多个线程都会检查信号量，信号量自身也需要进行并发处理（一般为锁），在第一个例子中，我们可以将其转化为：同时只能有一个病人检查门上的电子屏，当有多个病人想要检查电子屏上显示的数字时，他们同样需要排队。（排队限制了同一时间只有一个病人能够操作电子屏，电子屏即使这个例子中的临界区）

思考关于临界区的概念：临界区是共享资源前的一块区域，进程/线程进入这块区域后开始排队准备对共享资源进行操作。临界区自身也算是一种“共享资源”，为了处理对“临界区的共享”，一般也需要对临界区设置锁等操作。