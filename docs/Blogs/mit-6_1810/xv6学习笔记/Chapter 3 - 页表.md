每个进程都会被分到一块独立的内存空间，这块内存空间中的地址被映射到一张或几张页表上，进程使用页表访问内存。页表机制保证了进程不会访问非法的内存（即隔离了不同进程的内存空间），同时为进程提供了一个在它看来“从0开始”的内存空间，方便其访问。

xv6同时利用这个机制实现了一些技巧：在几个地址空间中映射同一内存（ trampoline 页），以及用一个未映射页来保护内核栈和用户栈。

### 3-1 页表硬件
> 一个RISC-V页表在逻辑上是一个由2²⁷（134,217,728）个<b>页表项（Page Table Entry, PTE）</b>组成的数组。每个**PTE**包含一个44位的<b>物理页号（Physical Page Number, PPN）</b>和一些标志位。分页硬件通过利用39位中的高27位索引到页表中找到一个**PTE**来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于**PTE**中的**PPN**，而它的后12位则是从原来的虚拟地址复制过来的。

页表硬件负责将页表中的虚拟地址映射为物理地址。虚拟地址为页表标号( index ) + 偏移量( offset )。页表标号对应了页表中的一项，此项为物理内存中的起始位置：该起始位置加上偏移量即为虚拟地址对应的物理地址。

即页表可以为简单地被看为一个存储了多个物理内存起始位置的数组，结合虚拟地址中的偏移量，虚拟地址可以被转换为物理地址。

每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。`PTE_V` 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。`PTE_R` 控制是否允许指令读取该页。`PTE_W` 控制是否允许指令向该页写入。`PTE_X` 控制 CPU 是否可以将页面的内容解释为指令并执行。`PTE_U` 控制是否允许用户态下的指令访问页面；如果不设置 `PTE_U`， 对应 PTE 只能在内核态下使用。

CPU内有 `satp` 寄存器记录需要使用的页表的物理位置，不同的CPU可以记录不同的页表，保证每个进程都有自己的页表所描述的内存空间。

### 3-2 内核地址空间

xv6为每个进程维护一个映射其用户地址空间的页表。对内核，维护一个单独的描述内核地址空间的页表，这个页表的配置是固定的以保证内核可以通过虚拟地址访问物理内存。

内核中的虚拟地址映射从地址 `0x80000000` 开始，到（至少） `0x86400000` 结束。 `0x80000000` 以下的内存用于I/O设备，内核可以通过读取/写入这些特殊的物理地址与设备进行交互。内核对设备寄存器和RAM（物理内存）使用直接映射。

内核中内核栈页与trampoline页不是直接映射。

- trampoline页：一个trampoline物理页（存放trampoline代码）被映射两次，一次在虚拟地址空间顶部，一次直接映射。

- 内核栈页：内核栈页被映射到地址空间的顶端后，在其后放置一个 `PTE_V` 无效的页（守护页），以保证在内核栈溢出时报错。

### 3-3 代码阅读：创建地址空间
本节中的主要代码位于 `kernel/vm.c` 。

核心数据结构： `pagetable_t` ，本质为一个指向根页表页的指针，它可以指向内核页表也可以指向进程页表。

首先 `main` 函数调用 `kvminit` 来创建内核页表并分配一页物理内存来存放根页表页，然后调用 `kvmmap` 将内核所需要的硬件资源映射到物理地址。这些资源包括内核的指令和数据。

产生映射时的核心函数：
- `mappages` ：将指定的物理地址通过 `walk` 映射到虚拟地址
- `walk` ：在页表中查找给定虚拟地址对应的页表项，并返回对应的页表项的地址。如果传入的 `alloc` 参数为1，则把页表中对应的一页“进行分配并初始化”。

```c
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
// va=虚拟内存起始地址，pa=物理内存起始地址，size=待映射地址空间大小。
// Create PTEs for virtual addresses starting at va that refer to physical addresses starting at pa.
{
  uint64 a, last;
  pte_t *pte;

  // 以页为单位，所以va和size都必须匹配PGSIZE
  if((va % PGSIZE) != 0)
    panic("mappages: va not aligned");

  if((size % PGSIZE) != 0)
    panic("mappages: size not aligned");

  if(size == 0)
    panic("mappages: size");

  a = va; // 当前虚拟地址
  last = va + size - PGSIZE; //虚拟地址范围的结束地址
  for(;;){
    if((pte = walk(pagetable, a, 1)) == 0) // // 调用 `walk` 函数来查找虚拟地址 `a` 对应的页表项的地址，并将结果存储在变量 `pte` 中。如果查找失败（即返回值为0），则说明页表项不存在，函数返回-1。
      return -1;
    if(*pte & PTE_V) // 检查页表项是否已经被映射。
      panic("mappages: remap");
    *pte = PA2PTE(pa) | perm | PTE_V; // 将页表项设置为有效，并存储相应的物理页号、权限标志等信息。`PA2PTE(pa)` 是将物理地址转换为页表项格式的宏，`perm` 表示要设置的权限标志，`PTE_V` 表示页表项有效。
    if(a == last)
      break;
    // 将地址向后移动一页大小，以处理下一个虚拟地址。
    a += PGSIZE;
    pa += PGSIZE;
  }
  return 0;
}
```

```c
pte_t *
walk(pagetable_t pagetable, uint64 va, int alloc)
{
  if(va >= MAXVA) // 检查虚拟地址是否超出了最大虚拟地址范围。如果超出了最大虚拟地址范围
    panic("walk");

  for(int level = 2; level > 0; level--) {
    pte_t *pte = &pagetable[PX(level, va)];
    // 根据当前级别和虚拟地址计算出对应的页表项的地址，并将其存储在变量 `pte` 中。
    
    if(*pte & PTE_V) {
	// 检查页表项是否有效。如果页表项有效（即 PTE_V 标志位已经被设置），则表示找到了对应的页表项，函数会返回该页表项的地址。
      pagetable = (pagetable_t)PTE2PA(*pte);
      // 将下一级页表的物理地址（存储在当前页表项中）作为下一级页表的地址，继续在下一级页表中查找。
    } else {
      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
        return 0; // 分配不成功或不分配
      memset(pagetable, 0, PGSIZE); // 初始化新分配的页面
      *pte = PA2PTE(pagetable) | PTE_V; // 设置相应的权限标志，并将下一级页表的物理地址存储在当前页表项中。
    }
  }
  return &pagetable[PX(0, va)]; // 返回最低级别的页表项的地址，即对应给定虚拟地址的页表项的地址。
}
```

> 疑问：怎么感觉实际上没有看到分配物理内存的部分？
> 一种回答：实际物理内存的分配由c语言隐式地完成，以上两个程序是将已经由c语言自动分配的物理内存映射到虚拟内存的过程（GPT说我是对的）

内核页表被映射后，根页表页的物理地址会被写入CPU的 `satp` 寄存器中，之后CPU会使用这个页表进行映射。

此处需要回顾计组中的TLB知识，即页表中的快表。xv6改变页表后，会使该页表在TLB中的对应索引项失效，否则可能导致进程访问非法的内存空间。

### 3-4 物理内存分配
xv6 使用内核地址结束到 `PHYSTOP` （物理地址结束的位置）之间的物理内存来进行运行时分配。它每次分配和释放整个4096 字节的页面。它通过保存空闲页链表，来记录哪些页是空闲的。分配包括从链表中删除一页；释放包括将释放的页面添加到空闲页链表中。

### 3-5 代码阅读：物理内存分配器
本节中的主要代码位于 `kernel/kalloc.c` 。