每个进程都会被分到一块独立的内存空间，这块内存空间中的地址被映射到一张或几张页表上，进程使用页表访问内存。页表机制保证了进程不会访问非法的内存（即隔离了不同进程的内存空间），同时为进程提供了一个在它看来“从0开始”的内存空间，方便其访问。

xv6同时利用这个机制实现了一些技巧：在几个地址空间中映射同一内存（ trampoline 页），以及用一个未映射页来保护内核栈和用户栈。

#### 3-1 页表硬件
> 一个RISC-V页表在逻辑上是一个由2²⁷（134,217,728）个<b>页表项（Page Table Entry, PTE）</b>组成的数组。每个**PTE**包含一个44位的<b>物理页号（Physical Page Number, PPN）</b>和一些标志位。分页硬件通过利用39位中的高27位索引到页表中找到一个**PTE**来转换一个虚拟地址，并计算出一个56位的物理地址，它的前44位来自于**PTE**中的**PPN**，而它的后12位则是从原来的虚拟地址复制过来的。

页表硬件负责将页表中的虚拟地址映射为物理地址。虚拟地址为页表标号( index ) + 偏移量( offset )。页表标号对应了页表中的一项，此项为物理内存中的起始位置：该起始位置加上偏移量即为虚拟地址对应的物理地址。

即页表可以为简单地被看为一个存储了多个物理内存起始位置的数组，结合虚拟地址中的偏移量，虚拟地址可以被转换为物理地址。

每个 PTE 都包含标志位，用于告诉分页硬件相关的虚拟地址被允许怎样使用。`PTE_V` 表示 PTE 是否存在：如果没有设置，对该页的引用会引起异常（即不允许）。`PTE_R` 控制是否允许指令读取该页。`PTE_W` 控制是否允许指令向该页写入。`PTE_X` 控制 CPU 是否可以将页面的内容解释为指令并执行。`PTE_U` 控制是否允许用户态下的指令访问页面；如果不设置 `PTE_U`， 对应 PTE 只能在内核态下使用。

CPU内有 `satp` 寄存器记录需要使用的页表的物理位置，不同的CPU可以记录不同的页表，保证每个进程都有自己的页表所描述的内存空间。

#### 内核地址空间

xv6为每个进程维护一个映射其用户地址空间的页表。对内核，维护一个单独的描述内核地址空间的页表，这个页表的配置是固定的以保证内核可以通过虚拟地址访问物理内存。

内核中的虚拟地址映射从地址 `0x80000000` 开始，到（至少） `0x86400000` 结束。 `0x80000000` 以下的内存用于I/O设备，内核可以通过读取/写入这些特殊的物理地址与设备进行交互。设备寄存器和RAM使用直接映射。

内核栈页与trampoline页不是直接映射。

（这节是在是没看懂，TODO补完）

#### 代码阅读：创建地址空间
