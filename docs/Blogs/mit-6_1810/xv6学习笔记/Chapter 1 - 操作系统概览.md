
#### 引入
操作系统的功能：向用户程序提供一系列包装好的接口以利用硬件资源，并且提供一种可控的多进程之间进行交互的方式。

当用户程序使用系统调用时，操作系统切换到内核态，执行调用的服务并返回结果。

xv6提供的系统调用：

| 系统调用                                        | 描述                                    |
| ------------------------------------------- | ------------------------------------- |
| **int fork()**                              | 创建一个进程，返回子进程的PID。                     |
| **int exit(int status)**                    | 终止当前进程，并将status传递给wait()。不会返回。        |
| **int wait(int \*status)**                  | 等待子进程结束，并将status接收到参数*status中，返回其PID。 |
| **int kill(int pid)**                       | 终止给定PID的进程，成功返回0，失败返回-1。              |
| **int getpid()**                            | 返回当前进程的PID。                           |
| **int sleep(int n)**                        | 睡眠n个时钟周期。                             |
| **int exec(char \*file, char \*argv[])**    | 通过给定参数加载并执行一个文件；只在错误时返回。              |
| **char \*sbrk(int n)**                      | 使进程内存增加n字节，返回新内存的起始地址。                |
| **int open(char \*file, int flags)**        | 打开一个文件，flags表示读或写，返回fd（文件描述符）。        |
| **int write(int fd, char \*buf, int n)**    | 将buf中n字节写入到文件描述符中；返回n。                |
| **int read(int fd, char \*buf, int n)**     | 从文件描述符中读取n字节到buf；返回读取字节数，文件结束返回0。     |
| **int close(int fd)**                       | 释放文件描述符fd。                            |
| **int dup(int fd)**                         | 返回一个新文件描述符，其引用与fd相同的文件。               |
| **int pipe(int p[])**                       | 创建管道，将读/写文件描述符放置在p[0]和p[1]。           |
| **int chdir(char \*dir)**                   | 改变当前目录。                               |
| **int mkdir(char \*dir)**                   | 创建新目录。                                |
| **int mknod(char \*file, int, int)**        | 创建新设备文件。                              |
| **int fstat(int fd, struct stat \*st)**     | 将打开的文件的信息放置在*st中。                     |
| **int stat(char \*file, struct stat \*st)** | 将命名文件信息放置在*st中。                       |
| **int link(char \*file1, char \* file2)**   | 为文件file1创建一个新的名称(file2)。              |
| **int unlink(char \*file)**                 | 移除一个文件。                               |

#### 1-1 进程与内存
PID是进程的标号，每个进程由用户空间内存（指令、数据和堆栈）和内核私有状态组成。

`fork()` **系统调用**可以创建一个新的进程，在父进程中返回**子进程**的PID（注意子进程的PID并不为0），在子进程中返回0。

`exit(int)` **系统调用**会使调用它的进程退出。它需要一个整型参数，0表示当前进程在成功状态下退出，1表示当前进程在失败状态下退出。 `exit(int)` 会将退出时的状态参数传给 `wait(int *)` 。

`wait(int *)` **系统调用**会返回退出的子进程的PID，并将该子进程的退出状态复制到作为参数的地址中。如果有已退出的子进程则直接返回，如果没有则等待一个子进程的退出，如果调用者没有子进程则返回-1。不关心子进程是如何退出时，可以将参数设为0地址（使状态复制的一步没有意义）。

> **exec**系统调用使用新内存映像来替换进程的内存， 新内存映像从文件系统中的文件中进行读取。

`exec(char *, char *[])` 约等于创造一个新的进程（原进程等于被释放），复制原进程的文件描述符表到新的内存，新内存将根据参数读取文件系统中对应文件的指令内容并执行。exec系统调用一般不返回值。

在不希望调用exec就使原进程结束时，一般会使用fork先创建子进程，在子进程中再调用exec。（关于内存分配：**fork**复制父进程的内存到子进程，**exec**分配足够的内存来容纳可执行文件。）
> 有一个例外，那就是cd，它是在shell中实现的 (user/sh.c:160)。cd 必须改变 shell 自身的当前工作目录。如果cd作为一个普通命令执行，那么shell就会fork一个子进程，而子进程会运行cd，cd只会改变子进程的当前工作目录。父进程（即shell）的工作目录则保持不变。

一个使用exec系统调用的例子：
```c
char* *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

#### 1-2 I/O与文件描述符
每个文件描述符都代表一个可由进程读取或写入的内核管理对象。**打开文件**（目录与硬件设备也是一种特殊的文件）、**创建管道**与**复制现有的文件描述符**都可以得到新的文件描述符。

每个进程都有自己独立的文件描述符表，按约定0代表读取标准输入，1代表写入标准输出，2代表写入标准错误。（注意此处的标准输入是指一般的程序默认从文件描述符0中读取数据，不是指文件描述符0绑定键盘输入）

`read(int fd, char* buf, int n)` 系统调用从文件描述符fd中读取不超过n字节的数据并复制到buf中，返回未读取的字节数（若读取完毕则返回0表示文件结束）。

`write(int fd, char* buf, int n)` 系统调用将buf中的n个字节写入文件描述符fd中，返回写入的字节数。

一个例子是从文件中读取内容并写入到标准输出的用户程序cat：
```c
char buf[512];
int n;
for (;;)
{
    n = read(0, buf, sizeof buf);
    if (n == 0)
        break;
    if (n < 0)
    {
        fprintf(2, "read error\n");
        exit(1);
    }
    if (write(1, buf, n) != n)
    {
        fprintf(2, "write error\n");
        exit(1);
	}
}
```
单独的cat命令只能从标准输入读入数据再将其写入标准输出，需要结合close系统调用将文件描述符0指向的文件由标准输入置换为需要读取的文件（I/O重定向）。

`close(int fd)` 系统调用关闭参数的文件描述符，使这个文件描述符悬空（不指向任何文件）。在此后创建新文件描述符关联某个文件（open、pipe、dup）时，会优先使用当前进程中最小的、悬空的文件描述符来关联该文件。例如shell运行cat指令的过程：
```c
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if (fork() == 0)
{
    close(0);  // 释放标准输入的文件描述符
    open("input.txt", O_RDONLY);  // 这时input.txt的文件描述符为0
    // 即标准输入为input.txt
    exec("cat", argv);  // cat从0读取，并输出到1，见上个代码段
}
```

文件描述符中储存有偏移量，以确保第二次打开文件时从偏移量后读写数据，在读取结束后按读写字节数推进偏移量。如果两个文件描述符是通过一系列的**fork**和**dup**调用从**同一个原始文件描述符**衍生出来的，那么这两个文件描述符共享一个偏移量。否则，文件描述符不共享偏移量，即使它们是由同一个文件的打开调用产生的。

`open(char* files, int flag)` 系统调用的第一个参数是文件路径，第二个参数由一组用位表示的标志组成，用来控制**open**的工作。**O_RDONLY,** **O_WRONLY,** **O_RDWR**, **O_CREATE**, 和 **O_TRUNC,** 它们分别指定open打开文件时的功能，读、写、读和写、如果文件不存在则创建文件、将文件长度截断为0。

`dup(int fd)` 系统调用复制现有的fd文件描述符，返回一个新的文件描述符并指向相同的文件。

#### Pipes管道
管道使用一块内核buffer进行数据传输，提供一对文件描述符给进程， `p[0]` 用于从管道读出数据， `p[1]` 用于向管道写入数据。管道可以用于父进程和子进程之间的通信：创建子进程后，父进程与子进程的管道文件描述符指向同一个管道，父进程与子进程均可以对这个管道进行读写。

通过对标准输入0的I/O重定向，可以实现读取文件中被另一个进程写入的内容，做到了进程之间的交互:
```c
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if (fork() == 0)
{
    close(0);  // 释放文件描述符0
    dup(p[0]); // 复制一个p[0](管道读端)，此时文件描述符0（标准输入）也引用管道读端，故改变了标准输入。
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv); // wc 从标准输入读取数据，并写入到参数中的每一个文件
}
else
{
    close(p[0]);
    write(p[1], "hello world\n", 12); // 父进程向管道写入数据
    close(p[1]);
}
```

在管道中没有数据可读取时，读取操作会一直等待，直到有数据写入或指向管道写端的**所有**文件描述符都被关闭（即管道写端文件inode的link数为0）。所以子进程等待读取数据时一般关闭自身进程中的管道写端，防止堵塞。

通过shell调用管道的过程：将管道指令设为一个包含左指令和右指令的结构体，在左端和右端分别调用**fork**和**runcmd**。
> 管道的右端（读取端）可以是一个命令，也可以是包含管道的多个命令（例如，**a | b | c**），它又会分叉为两个新的子进程（一个是**b**，一个是**c**）。因此，shell可以创建一棵进程树。这棵树的叶子是命令，内部（非叶子）节点是等待左右子进程结束的进程。

shell调用管道的代码如下：
```c
struct pipecmd {
int type;
struct cmd *left;
struct cmd *right;
};

int
fork1(void)
{
	int pid;
	pid = fork();

	if(pid == -1)
		panic("fork");
	return pid;
}

case PIPE:
	pcmd = (struct pipecmd*)cmd;
	
	if(pipe(p) < 0)
		panic("pipe");
	
	if(fork1() == 0){
		close(1);
		dup(p[1]);
		close(p[0]);
		close(p[1]);
		runcmd(pcmd->left); // 执行左指令，执行完毕后退出，不会执行下面的命令
	}
	
	if(fork1() == 0){
		close(0);
		dup(p[0]);		
		close(p[0]);
		close(p[1]);
		runcmd(pcmd->right); // 执行右指令（可能递归建树）
	}
	
	close(p[0]);
	close(p[1]);
	
	wait(0);
	wait(0);
	break;
```

所以shell调用管道命令时创造的进程树大致为
```
			origin shell process
			/                 \
		   /                   \
		left cmd process        origin process
		(exit)                 /             \
						      /                \
						right cmd process 	  origin process
						(exit)
```

> 管道比临时文件至少有四个优势。首先，管道会自动清理自己；如果是文件重定向，shell在完成后必须小心地删除/tmp/xyz。第二，管道可以传递任意长的数据流，而文件重定向则需要磁盘上有足够的空闲空间来存储所有数据。第三，管道可以分阶段的并行执行，而文件方式则需要在第二个程序开始之前完成第一个程序。第四，如果你要实现进程间的通信，管道阻塞读写比文件的非阻塞语义更有效率。

#### 1-4 filesystem
参见文件系统学习笔记

#### 1-5 主要是水话